// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PPUCOMMANDS_PPUCOMMAND_H_
#define FLATBUFFERS_GENERATED_PPUCOMMANDS_PPUCOMMAND_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace PPUCommand {

struct Reset;
struct ResetBuilder;

struct RunLine;

struct Read;

struct Write;

struct WriteCGRam;
struct WriteCGRamBuilder;

struct WriteOAM;
struct WriteOAMBuilder;

struct BeginDrawing;
struct BeginDrawingBuilder;

struct GetCurrentRenderScale;

struct SetMode7PerspectiveCorrection;

struct SetExtraSideSpace;

struct GetMode;

struct GetExtraLeftRight;

struct SetExtraLeftRight;

struct Command;
struct CommandBuilder;

struct CommandList;
struct CommandListBuilder;

enum CommandType : uint8_t {
  CommandType_NONE = 0,
  CommandType_Reset = 1,
  CommandType_RunLine = 2,
  CommandType_Read = 3,
  CommandType_Write = 4,
  CommandType_WriteCGRam = 5,
  CommandType_WriteOAM = 6,
  CommandType_BeginDrawing = 7,
  CommandType_GetCurrentRenderScale = 8,
  CommandType_SetMode7PerspectiveCorrection = 9,
  CommandType_SetExtraSideSpace = 10,
  CommandType_GetMode = 11,
  CommandType_GetExtraLeftRight = 12,
  CommandType_SetExtraLeftRight = 13,
  CommandType_MIN = CommandType_NONE,
  CommandType_MAX = CommandType_SetExtraLeftRight
};

inline const CommandType (&EnumValuesCommandType())[14] {
  static const CommandType values[] = {
    CommandType_NONE,
    CommandType_Reset,
    CommandType_RunLine,
    CommandType_Read,
    CommandType_Write,
    CommandType_WriteCGRam,
    CommandType_WriteOAM,
    CommandType_BeginDrawing,
    CommandType_GetCurrentRenderScale,
    CommandType_SetMode7PerspectiveCorrection,
    CommandType_SetExtraSideSpace,
    CommandType_GetMode,
    CommandType_GetExtraLeftRight,
    CommandType_SetExtraLeftRight
  };
  return values;
}

inline const char * const *EnumNamesCommandType() {
  static const char * const names[15] = {
    "NONE",
    "Reset",
    "RunLine",
    "Read",
    "Write",
    "WriteCGRam",
    "WriteOAM",
    "BeginDrawing",
    "GetCurrentRenderScale",
    "SetMode7PerspectiveCorrection",
    "SetExtraSideSpace",
    "GetMode",
    "GetExtraLeftRight",
    "SetExtraLeftRight",
    nullptr
  };
  return names;
}

inline const char *EnumNameCommandType(CommandType e) {
  if (::flatbuffers::IsOutRange(e, CommandType_NONE, CommandType_SetExtraLeftRight)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCommandType()[index];
}

template<typename T> struct CommandTypeTraits {
  static const CommandType enum_value = CommandType_NONE;
};

template<> struct CommandTypeTraits<PPUCommand::Reset> {
  static const CommandType enum_value = CommandType_Reset;
};

template<> struct CommandTypeTraits<PPUCommand::RunLine> {
  static const CommandType enum_value = CommandType_RunLine;
};

template<> struct CommandTypeTraits<PPUCommand::Read> {
  static const CommandType enum_value = CommandType_Read;
};

template<> struct CommandTypeTraits<PPUCommand::Write> {
  static const CommandType enum_value = CommandType_Write;
};

template<> struct CommandTypeTraits<PPUCommand::WriteCGRam> {
  static const CommandType enum_value = CommandType_WriteCGRam;
};

template<> struct CommandTypeTraits<PPUCommand::WriteOAM> {
  static const CommandType enum_value = CommandType_WriteOAM;
};

template<> struct CommandTypeTraits<PPUCommand::BeginDrawing> {
  static const CommandType enum_value = CommandType_BeginDrawing;
};

template<> struct CommandTypeTraits<PPUCommand::GetCurrentRenderScale> {
  static const CommandType enum_value = CommandType_GetCurrentRenderScale;
};

template<> struct CommandTypeTraits<PPUCommand::SetMode7PerspectiveCorrection> {
  static const CommandType enum_value = CommandType_SetMode7PerspectiveCorrection;
};

template<> struct CommandTypeTraits<PPUCommand::SetExtraSideSpace> {
  static const CommandType enum_value = CommandType_SetExtraSideSpace;
};

template<> struct CommandTypeTraits<PPUCommand::GetMode> {
  static const CommandType enum_value = CommandType_GetMode;
};

template<> struct CommandTypeTraits<PPUCommand::GetExtraLeftRight> {
  static const CommandType enum_value = CommandType_GetExtraLeftRight;
};

template<> struct CommandTypeTraits<PPUCommand::SetExtraLeftRight> {
  static const CommandType enum_value = CommandType_SetExtraLeftRight;
};

bool VerifyCommandType(::flatbuffers::Verifier &verifier, const void *obj, CommandType type);
bool VerifyCommandTypeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) RunLine FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t line_;

 public:
  RunLine()
      : line_(0) {
  }
  RunLine(int32_t _line)
      : line_(::flatbuffers::EndianScalar(_line)) {
  }
  int32_t line() const {
    return ::flatbuffers::EndianScalar(line_);
  }
  void mutate_line(int32_t _line) {
    ::flatbuffers::WriteScalar(&line_, _line);
  }
};
FLATBUFFERS_STRUCT_END(RunLine, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Read FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t addr_;
  uint8_t result_;

 public:
  Read()
      : addr_(0),
        result_(0) {
  }
  Read(uint8_t _addr, uint8_t _result)
      : addr_(::flatbuffers::EndianScalar(_addr)),
        result_(::flatbuffers::EndianScalar(_result)) {
  }
  uint8_t addr() const {
    return ::flatbuffers::EndianScalar(addr_);
  }
  void mutate_addr(uint8_t _addr) {
    ::flatbuffers::WriteScalar(&addr_, _addr);
  }
  uint8_t result() const {
    return ::flatbuffers::EndianScalar(result_);
  }
  void mutate_result(uint8_t _result) {
    ::flatbuffers::WriteScalar(&result_, _result);
  }
};
FLATBUFFERS_STRUCT_END(Read, 2);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Write FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t adr_;
  uint8_t value_;

 public:
  Write()
      : adr_(0),
        value_(0) {
  }
  Write(uint8_t _adr, uint8_t _value)
      : adr_(::flatbuffers::EndianScalar(_adr)),
        value_(::flatbuffers::EndianScalar(_value)) {
  }
  uint8_t adr() const {
    return ::flatbuffers::EndianScalar(adr_);
  }
  void mutate_adr(uint8_t _adr) {
    ::flatbuffers::WriteScalar(&adr_, _adr);
  }
  uint8_t value() const {
    return ::flatbuffers::EndianScalar(value_);
  }
  void mutate_value(uint8_t _value) {
    ::flatbuffers::WriteScalar(&value_, _value);
  }
};
FLATBUFFERS_STRUCT_END(Write, 2);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) GetCurrentRenderScale FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t render_flags_;
  int32_t result_;

 public:
  GetCurrentRenderScale()
      : render_flags_(0),
        result_(0) {
  }
  GetCurrentRenderScale(uint32_t _render_flags, int32_t _result)
      : render_flags_(::flatbuffers::EndianScalar(_render_flags)),
        result_(::flatbuffers::EndianScalar(_result)) {
  }
  uint32_t render_flags() const {
    return ::flatbuffers::EndianScalar(render_flags_);
  }
  void mutate_render_flags(uint32_t _render_flags) {
    ::flatbuffers::WriteScalar(&render_flags_, _render_flags);
  }
  int32_t result() const {
    return ::flatbuffers::EndianScalar(result_);
  }
  void mutate_result(int32_t _result) {
    ::flatbuffers::WriteScalar(&result_, _result);
  }
};
FLATBUFFERS_STRUCT_END(GetCurrentRenderScale, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) SetMode7PerspectiveCorrection FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t low_;
  int32_t high_;

 public:
  SetMode7PerspectiveCorrection()
      : low_(0),
        high_(0) {
  }
  SetMode7PerspectiveCorrection(int32_t _low, int32_t _high)
      : low_(::flatbuffers::EndianScalar(_low)),
        high_(::flatbuffers::EndianScalar(_high)) {
  }
  int32_t low() const {
    return ::flatbuffers::EndianScalar(low_);
  }
  void mutate_low(int32_t _low) {
    ::flatbuffers::WriteScalar(&low_, _low);
  }
  int32_t high() const {
    return ::flatbuffers::EndianScalar(high_);
  }
  void mutate_high(int32_t _high) {
    ::flatbuffers::WriteScalar(&high_, _high);
  }
};
FLATBUFFERS_STRUCT_END(SetMode7PerspectiveCorrection, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) SetExtraSideSpace FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t left_;
  int32_t right_;
  int32_t bottom_;

 public:
  SetExtraSideSpace()
      : left_(0),
        right_(0),
        bottom_(0) {
  }
  SetExtraSideSpace(int32_t _left, int32_t _right, int32_t _bottom)
      : left_(::flatbuffers::EndianScalar(_left)),
        right_(::flatbuffers::EndianScalar(_right)),
        bottom_(::flatbuffers::EndianScalar(_bottom)) {
  }
  int32_t left() const {
    return ::flatbuffers::EndianScalar(left_);
  }
  void mutate_left(int32_t _left) {
    ::flatbuffers::WriteScalar(&left_, _left);
  }
  int32_t right() const {
    return ::flatbuffers::EndianScalar(right_);
  }
  void mutate_right(int32_t _right) {
    ::flatbuffers::WriteScalar(&right_, _right);
  }
  int32_t bottom() const {
    return ::flatbuffers::EndianScalar(bottom_);
  }
  void mutate_bottom(int32_t _bottom) {
    ::flatbuffers::WriteScalar(&bottom_, _bottom);
  }
};
FLATBUFFERS_STRUCT_END(SetExtraSideSpace, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) GetMode FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t result_;

 public:
  GetMode()
      : result_(0) {
  }
  GetMode(uint8_t _result)
      : result_(::flatbuffers::EndianScalar(_result)) {
  }
  uint8_t result() const {
    return ::flatbuffers::EndianScalar(result_);
  }
  void mutate_result(uint8_t _result) {
    ::flatbuffers::WriteScalar(&result_, _result);
  }
};
FLATBUFFERS_STRUCT_END(GetMode, 1);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) GetExtraLeftRight FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t result_;

 public:
  GetExtraLeftRight()
      : result_(0) {
  }
  GetExtraLeftRight(uint8_t _result)
      : result_(::flatbuffers::EndianScalar(_result)) {
  }
  uint8_t result() const {
    return ::flatbuffers::EndianScalar(result_);
  }
  void mutate_result(uint8_t _result) {
    ::flatbuffers::WriteScalar(&result_, _result);
  }
};
FLATBUFFERS_STRUCT_END(GetExtraLeftRight, 1);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) SetExtraLeftRight FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t extra_left_right_;

 public:
  SetExtraLeftRight()
      : extra_left_right_(0) {
  }
  SetExtraLeftRight(uint8_t _extra_left_right)
      : extra_left_right_(::flatbuffers::EndianScalar(_extra_left_right)) {
  }
  uint8_t extra_left_right() const {
    return ::flatbuffers::EndianScalar(extra_left_right_);
  }
  void mutate_extra_left_right(uint8_t _extra_left_right) {
    ::flatbuffers::WriteScalar(&extra_left_right_, _extra_left_right);
  }
};
FLATBUFFERS_STRUCT_END(SetExtraLeftRight, 1);

struct Reset FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResetBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ResetBuilder {
  typedef Reset Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ResetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Reset> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Reset>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Reset> CreateReset(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  ResetBuilder builder_(_fbb);
  return builder_.Finish();
}

struct WriteCGRam FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WriteCGRamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  ::flatbuffers::Vector<uint8_t> *mutable_data() {
    return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct WriteCGRamBuilder {
  typedef WriteCGRam Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(WriteCGRam::VT_DATA, data);
  }
  explicit WriteCGRamBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WriteCGRam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WriteCGRam>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WriteCGRam> CreateWriteCGRam(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  WriteCGRamBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<WriteCGRam> CreateWriteCGRamDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return PPUCommand::CreateWriteCGRam(
      _fbb,
      data__);
}

struct WriteOAM FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WriteOAMBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  ::flatbuffers::Vector<uint8_t> *mutable_data() {
    return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct WriteOAMBuilder {
  typedef WriteOAM Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(WriteOAM::VT_DATA, data);
  }
  explicit WriteOAMBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WriteOAM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WriteOAM>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WriteOAM> CreateWriteOAM(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  WriteOAMBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<WriteOAM> CreateWriteOAMDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return PPUCommand::CreateWriteOAM(
      _fbb,
      data__);
}

struct BeginDrawing FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BeginDrawingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUFFER_SIZE = 4,
    VT_PITCH = 6,
    VT_RENDER_FLAGS = 8
  };
  int32_t buffer_size() const {
    return GetField<int32_t>(VT_BUFFER_SIZE, 0);
  }
  bool mutate_buffer_size(int32_t _buffer_size = 0) {
    return SetField<int32_t>(VT_BUFFER_SIZE, _buffer_size, 0);
  }
  int32_t pitch() const {
    return GetField<int32_t>(VT_PITCH, 0);
  }
  bool mutate_pitch(int32_t _pitch = 0) {
    return SetField<int32_t>(VT_PITCH, _pitch, 0);
  }
  uint32_t render_flags() const {
    return GetField<uint32_t>(VT_RENDER_FLAGS, 0);
  }
  bool mutate_render_flags(uint32_t _render_flags = 0) {
    return SetField<uint32_t>(VT_RENDER_FLAGS, _render_flags, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BUFFER_SIZE, 4) &&
           VerifyField<int32_t>(verifier, VT_PITCH, 4) &&
           VerifyField<uint32_t>(verifier, VT_RENDER_FLAGS, 4) &&
           verifier.EndTable();
  }
};

struct BeginDrawingBuilder {
  typedef BeginDrawing Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_buffer_size(int32_t buffer_size) {
    fbb_.AddElement<int32_t>(BeginDrawing::VT_BUFFER_SIZE, buffer_size, 0);
  }
  void add_pitch(int32_t pitch) {
    fbb_.AddElement<int32_t>(BeginDrawing::VT_PITCH, pitch, 0);
  }
  void add_render_flags(uint32_t render_flags) {
    fbb_.AddElement<uint32_t>(BeginDrawing::VT_RENDER_FLAGS, render_flags, 0);
  }
  explicit BeginDrawingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BeginDrawing> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BeginDrawing>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BeginDrawing> CreateBeginDrawing(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t buffer_size = 0,
    int32_t pitch = 0,
    uint32_t render_flags = 0) {
  BeginDrawingBuilder builder_(_fbb);
  builder_.add_render_flags(render_flags);
  builder_.add_pitch(pitch);
  builder_.add_buffer_size(buffer_size);
  return builder_.Finish();
}

struct Command FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMAND_TYPE = 4,
    VT_COMMAND = 6
  };
  PPUCommand::CommandType command_type() const {
    return static_cast<PPUCommand::CommandType>(GetField<uint8_t>(VT_COMMAND_TYPE, 0));
  }
  const void *command() const {
    return GetPointer<const void *>(VT_COMMAND);
  }
  template<typename T> const T *command_as() const;
  const PPUCommand::Reset *command_as_Reset() const {
    return command_type() == PPUCommand::CommandType_Reset ? static_cast<const PPUCommand::Reset *>(command()) : nullptr;
  }
  const PPUCommand::RunLine *command_as_RunLine() const {
    return command_type() == PPUCommand::CommandType_RunLine ? static_cast<const PPUCommand::RunLine *>(command()) : nullptr;
  }
  const PPUCommand::Read *command_as_Read() const {
    return command_type() == PPUCommand::CommandType_Read ? static_cast<const PPUCommand::Read *>(command()) : nullptr;
  }
  const PPUCommand::Write *command_as_Write() const {
    return command_type() == PPUCommand::CommandType_Write ? static_cast<const PPUCommand::Write *>(command()) : nullptr;
  }
  const PPUCommand::WriteCGRam *command_as_WriteCGRam() const {
    return command_type() == PPUCommand::CommandType_WriteCGRam ? static_cast<const PPUCommand::WriteCGRam *>(command()) : nullptr;
  }
  const PPUCommand::WriteOAM *command_as_WriteOAM() const {
    return command_type() == PPUCommand::CommandType_WriteOAM ? static_cast<const PPUCommand::WriteOAM *>(command()) : nullptr;
  }
  const PPUCommand::BeginDrawing *command_as_BeginDrawing() const {
    return command_type() == PPUCommand::CommandType_BeginDrawing ? static_cast<const PPUCommand::BeginDrawing *>(command()) : nullptr;
  }
  const PPUCommand::GetCurrentRenderScale *command_as_GetCurrentRenderScale() const {
    return command_type() == PPUCommand::CommandType_GetCurrentRenderScale ? static_cast<const PPUCommand::GetCurrentRenderScale *>(command()) : nullptr;
  }
  const PPUCommand::SetMode7PerspectiveCorrection *command_as_SetMode7PerspectiveCorrection() const {
    return command_type() == PPUCommand::CommandType_SetMode7PerspectiveCorrection ? static_cast<const PPUCommand::SetMode7PerspectiveCorrection *>(command()) : nullptr;
  }
  const PPUCommand::SetExtraSideSpace *command_as_SetExtraSideSpace() const {
    return command_type() == PPUCommand::CommandType_SetExtraSideSpace ? static_cast<const PPUCommand::SetExtraSideSpace *>(command()) : nullptr;
  }
  const PPUCommand::GetMode *command_as_GetMode() const {
    return command_type() == PPUCommand::CommandType_GetMode ? static_cast<const PPUCommand::GetMode *>(command()) : nullptr;
  }
  const PPUCommand::GetExtraLeftRight *command_as_GetExtraLeftRight() const {
    return command_type() == PPUCommand::CommandType_GetExtraLeftRight ? static_cast<const PPUCommand::GetExtraLeftRight *>(command()) : nullptr;
  }
  const PPUCommand::SetExtraLeftRight *command_as_SetExtraLeftRight() const {
    return command_type() == PPUCommand::CommandType_SetExtraLeftRight ? static_cast<const PPUCommand::SetExtraLeftRight *>(command()) : nullptr;
  }
  void *mutable_command() {
    return GetPointer<void *>(VT_COMMAND);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_COMMAND_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMMAND) &&
           VerifyCommandType(verifier, command(), command_type()) &&
           verifier.EndTable();
  }
};

template<> inline const PPUCommand::Reset *Command::command_as<PPUCommand::Reset>() const {
  return command_as_Reset();
}

template<> inline const PPUCommand::RunLine *Command::command_as<PPUCommand::RunLine>() const {
  return command_as_RunLine();
}

template<> inline const PPUCommand::Read *Command::command_as<PPUCommand::Read>() const {
  return command_as_Read();
}

template<> inline const PPUCommand::Write *Command::command_as<PPUCommand::Write>() const {
  return command_as_Write();
}

template<> inline const PPUCommand::WriteCGRam *Command::command_as<PPUCommand::WriteCGRam>() const {
  return command_as_WriteCGRam();
}

template<> inline const PPUCommand::WriteOAM *Command::command_as<PPUCommand::WriteOAM>() const {
  return command_as_WriteOAM();
}

template<> inline const PPUCommand::BeginDrawing *Command::command_as<PPUCommand::BeginDrawing>() const {
  return command_as_BeginDrawing();
}

template<> inline const PPUCommand::GetCurrentRenderScale *Command::command_as<PPUCommand::GetCurrentRenderScale>() const {
  return command_as_GetCurrentRenderScale();
}

template<> inline const PPUCommand::SetMode7PerspectiveCorrection *Command::command_as<PPUCommand::SetMode7PerspectiveCorrection>() const {
  return command_as_SetMode7PerspectiveCorrection();
}

template<> inline const PPUCommand::SetExtraSideSpace *Command::command_as<PPUCommand::SetExtraSideSpace>() const {
  return command_as_SetExtraSideSpace();
}

template<> inline const PPUCommand::GetMode *Command::command_as<PPUCommand::GetMode>() const {
  return command_as_GetMode();
}

template<> inline const PPUCommand::GetExtraLeftRight *Command::command_as<PPUCommand::GetExtraLeftRight>() const {
  return command_as_GetExtraLeftRight();
}

template<> inline const PPUCommand::SetExtraLeftRight *Command::command_as<PPUCommand::SetExtraLeftRight>() const {
  return command_as_SetExtraLeftRight();
}

struct CommandBuilder {
  typedef Command Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_command_type(PPUCommand::CommandType command_type) {
    fbb_.AddElement<uint8_t>(Command::VT_COMMAND_TYPE, static_cast<uint8_t>(command_type), 0);
  }
  void add_command(::flatbuffers::Offset<void> command) {
    fbb_.AddOffset(Command::VT_COMMAND, command);
  }
  explicit CommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Command> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Command>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Command> CreateCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    PPUCommand::CommandType command_type = PPUCommand::CommandType_NONE,
    ::flatbuffers::Offset<void> command = 0) {
  CommandBuilder builder_(_fbb);
  builder_.add_command(command);
  builder_.add_command_type(command_type);
  return builder_.Finish();
}

struct CommandList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CommandListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMANDS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<PPUCommand::Command>> *commands() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<PPUCommand::Command>> *>(VT_COMMANDS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<PPUCommand::Command>> *mutable_commands() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<PPUCommand::Command>> *>(VT_COMMANDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMANDS) &&
           verifier.VerifyVector(commands()) &&
           verifier.VerifyVectorOfTables(commands()) &&
           verifier.EndTable();
  }
};

struct CommandListBuilder {
  typedef CommandList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_commands(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PPUCommand::Command>>> commands) {
    fbb_.AddOffset(CommandList::VT_COMMANDS, commands);
  }
  explicit CommandListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CommandList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CommandList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CommandList> CreateCommandList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<PPUCommand::Command>>> commands = 0) {
  CommandListBuilder builder_(_fbb);
  builder_.add_commands(commands);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CommandList> CreateCommandListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<PPUCommand::Command>> *commands = nullptr) {
  auto commands__ = commands ? _fbb.CreateVector<::flatbuffers::Offset<PPUCommand::Command>>(*commands) : 0;
  return PPUCommand::CreateCommandList(
      _fbb,
      commands__);
}

inline bool VerifyCommandType(::flatbuffers::Verifier &verifier, const void *obj, CommandType type) {
  switch (type) {
    case CommandType_NONE: {
      return true;
    }
    case CommandType_Reset: {
      auto ptr = reinterpret_cast<const PPUCommand::Reset *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case CommandType_RunLine: {
      return verifier.VerifyField<PPUCommand::RunLine>(static_cast<const uint8_t *>(obj), 0, 4);
    }
    case CommandType_Read: {
      return verifier.VerifyField<PPUCommand::Read>(static_cast<const uint8_t *>(obj), 0, 1);
    }
    case CommandType_Write: {
      return verifier.VerifyField<PPUCommand::Write>(static_cast<const uint8_t *>(obj), 0, 1);
    }
    case CommandType_WriteCGRam: {
      auto ptr = reinterpret_cast<const PPUCommand::WriteCGRam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case CommandType_WriteOAM: {
      auto ptr = reinterpret_cast<const PPUCommand::WriteOAM *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case CommandType_BeginDrawing: {
      auto ptr = reinterpret_cast<const PPUCommand::BeginDrawing *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case CommandType_GetCurrentRenderScale: {
      return verifier.VerifyField<PPUCommand::GetCurrentRenderScale>(static_cast<const uint8_t *>(obj), 0, 4);
    }
    case CommandType_SetMode7PerspectiveCorrection: {
      return verifier.VerifyField<PPUCommand::SetMode7PerspectiveCorrection>(static_cast<const uint8_t *>(obj), 0, 4);
    }
    case CommandType_SetExtraSideSpace: {
      return verifier.VerifyField<PPUCommand::SetExtraSideSpace>(static_cast<const uint8_t *>(obj), 0, 4);
    }
    case CommandType_GetMode: {
      return verifier.VerifyField<PPUCommand::GetMode>(static_cast<const uint8_t *>(obj), 0, 1);
    }
    case CommandType_GetExtraLeftRight: {
      return verifier.VerifyField<PPUCommand::GetExtraLeftRight>(static_cast<const uint8_t *>(obj), 0, 1);
    }
    case CommandType_SetExtraLeftRight: {
      return verifier.VerifyField<PPUCommand::SetExtraLeftRight>(static_cast<const uint8_t *>(obj), 0, 1);
    }
    default: return true;
  }
}

inline bool VerifyCommandTypeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyCommandType(
        verifier,  values->Get(i), types->GetEnum<CommandType>(i))) {
      return false;
    }
  }
  return true;
}

inline const PPUCommand::CommandList *GetCommandList(const void *buf) {
  return ::flatbuffers::GetRoot<PPUCommand::CommandList>(buf);
}

inline const PPUCommand::CommandList *GetSizePrefixedCommandList(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<PPUCommand::CommandList>(buf);
}

inline CommandList *GetMutableCommandList(void *buf) {
  return ::flatbuffers::GetMutableRoot<CommandList>(buf);
}

inline PPUCommand::CommandList *GetMutableSizePrefixedCommandList(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<PPUCommand::CommandList>(buf);
}

inline bool VerifyCommandListBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<PPUCommand::CommandList>(nullptr);
}

inline bool VerifySizePrefixedCommandListBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<PPUCommand::CommandList>(nullptr);
}

inline void FinishCommandListBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<PPUCommand::CommandList> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedCommandListBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<PPUCommand::CommandList> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace PPUCommand

#endif  // FLATBUFFERS_GENERATED_PPUCOMMANDS_PPUCOMMAND_H_
